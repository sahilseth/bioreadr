

# gatk 4.1.1.0 --------
# Mutect2
# 
# Overhaul of FilterMutectCalls, which now applies a single threshold to an overall error probability (#5688)
# FilterMutectCalls automatically determines the optimal threshold.
# The new somatic clustering model learns tumors' allele fraction spectra and overall SNV and indel mutation rates in order to improve filtering.
# Includes a rewrite of Mutect2 documentation -- better organization and now includes command line examples in addition to math.
# Mutect2 now modifies base and indel qualities of overlapping paired reads to account for PCR error rather than discarding reads (#5794)
# This especially improves indel sensitivity.
# Optimized Mutect2 read orientation filtering by collecting F1R2 counts from within Mutect2 itself, greatly reducing wall-clock and CPU time (#5840)
# New Mutect2 panel of normals workflow using GenomicsDB for scalability (#5675)
# Panel of normals removes germline variants in order to contain only technical artifacts, and contains information about artifact prevalence
# Rewrote Mutect2 active region likelihood as special case of full somatic likelihoods model, which reduces runtime by 5% (#5814)
# Funcotator updates in Mutect2 WDL (#5742) (#5735)
# Prune assemby graph before checking for cycles (#5562)
# Refactor Mutect2 inheritance so that it doesn't have inactive arguments (#5758)
# Added CRAM support to the Mutect2 WDL (#5668)
# Split MNPs in Mutect2 PON WDL, fixing a potential bug (#5706)
# Handle negative infinity log likelihoods from PairHMM in Mutect2 (#5736)
# Fixed overfiltering in Mutect2 in GGA alleles mode with no reads (#5743)
# Correct some Mutect2 VCF header lines (#5792)
# Handle unmarked duplicates with mate MQ = 0 in Mutect2 (#5734)
# Output sample names in Mutect2 PON header (#5733)
# Avoid error due to finite precision error in Mutect2 PON creation (#5797)
# Update Mutect2 javadoc to reflect v4.1 changes. (#5769)
# Renamed the OxoGReadCounts annotation to OrientationBiasReadCounts (#5840)



## ** Primary resources ** (optional but strongly recommended)
## pon, pon_index: optional panel of normals in VCF format containing probable technical artifacts (false positves)
## gnomad, gnomad_index: optional database of known germline variants (see http://gnomad.broadinstitute.org/downloads)
## variants_for_contamination, variants_for_contamination_index: VCF of common variants with allele frequencies for calculating contamination
##
## ** Secondary resources ** (for optional tasks)
## onco_ds_tar_gz, default_config_file: Oncotator datasources and config file
## sequencing_center, sequence_source: metadata for Oncotator
## filter_oncotator_maf: Whether the MAF generated by oncotator should have the filtered variants removed. Default: true
## realignment_index_bundle: resource for FilterAlignmentArtifacts, which runs if and only if it is specified.  Generated by BwaMemIndexImageCreator.

# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf . # Mutect2.gnomad 
# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf.idx . # Mutect2.gnomad_index
# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf . # Mutect2.variants_for_contamination 
# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf.idx . # Mutect2.variants_for_contamination_index 
# gsutil ls gs://gatk-best-practices/somatic-b37
# gs://gatk-best-practices/somatic-b37/
# gs://gatk-best-practices/somatic-b37/CNV.hg19.bypos.v1.CR1_event_added.mod.seg
# gs://gatk-best-practices/somatic-b37/HCC1143.bai
# gs://gatk-best-practices/somatic-b37/HCC1143.bam
# gs://gatk-best-practices/somatic-b37/HCC1143_normal.bai
# gs://gatk-best-practices/somatic-b37/HCC1143_normal.bam
# gs://gatk-best-practices/somatic-b37/Homo_sapiens_assembly19.dict
# gs://gatk-best-practices/somatic-b37/Homo_sapiens_assembly19.fasta
# gs://gatk-best-practices/somatic-b37/Homo_sapiens_assembly19.fasta.fai
# gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf
# gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf.idx
# gs://gatk-best-practices/somatic-b37/final_centromere_hg19.seg
# gs://gatk-best-practices/somatic-b37/onco_config.txt
# gs://gatk-best-practices/somatic-b37/oncotator_v1_ds_April052016.tar.gz
# gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf
# gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf.idx
# gs://gatk-best-practices/somatic-b37/whole_exome_agilent_1.1_refseq_plus_3_boosters.Homo_sapiens_assembly19.baits.interval_list
# gs://gatk-best-practices/somatic-b37/whole_exome_agilent_1.1_refseq_plus_3_boosters.Homo_sapiens_assembly19.targets.interval_list


# *** split intervals for mutect:
# interval=whole_exome_agilent_1.1_refseq_plus_3_boosters.Homo_sapiens_assembly19.targets.interval_list
# gatk SplitIntervals -R Homo_sapiens_assembly19.fasta -L ${interval} --scatter-count 20 -O .

# **** CREATE contamination VCF -------
# https://gatkforums.broadinstitute.org/gatk/discussion/1255/using-jexl-to-apply-hard-filters-or-select-varia
# https://gatkforums.broadinstitute.org/gatk/discussion/comment/21120#Comment_21120; issue with multi allelic sites
# gatk SelectVariants -V af-only-gnomad.raw.sites.vcf -L 1 -R Homo_sapiens_assembly19.fasta --select 'AF.0 > 0.05' -O af-only-gnomad.raw.sites_for_contamination_chr1.vcf
# gatk IndexFeatureFile af-only-gnomad.raw.sites_for_contamination_chr1.vcf


# **** ARTEFECT filtering -----
# Mutect2.artifact_modes -- List of artifact modes to search for in the orientation bias filter. For example to filter the OxoG artifact, you would specify ["G/T"]. For both the FFPE artifact and the OxoG artifact, specify ["G/T", "C/T"]. If you do not wish to search for any artifacts, please set Mutect2_Multi.is_run_orientation_bias_filter to false.

# ** optimizing speed -------
# I heard back from a developer, and he has some questions/tips which I will relay here.
# 1) Do you have the log (stdout + stderr) for the GATK4 non-spark run? Can you post it? The developers need to know which pairhmm you are running with.
# 2) What sort of hardware are you running on? Specifically, is it an Intel machine with support for AVX?
# 3) A good setting for--nativePairHmmThreads is probably 4-8; you won't see any improvement after that.
# 4) You are setting -XX:+UseParallelGC -XX:ParallelGCThreads=32 for the GATK3 run. You would be better off setting it to 2-4 threads. Performance gets worse beyond that typically from what the developers have seen. You can set the same thing in GATK4 using--javaOptions ' -XX:+UseParallelGC -XX:ParallelGCThreads=4' This will also give us a better comparison.
# 5) In general, you want executors with ~4-8 cores and at least 4g of memory per core. How much memory do your nodes have and are you running with autoscaling turned on? I suspect you are only allocating 1 executor on 1 node and then it's thrashing memory because it's trying to run 32 threads at once. Spark tuning for HaplotypeCaller is going to be complicated. The developers don't know how to do it well yet, but they will be working on it in the next few months. It looks like you are running with Spark 2.1.0. GATK4 currently requires Spark 2.0.2 (which is unfortunately a specific version), but the developers are planning on upgrading to spark 2.2.+ in the next few months.
# To be clear, the results will not be the same between GATK3, GATK4, and GATK4-spark yet. GATK4 is in a rapid state of flux and has known performance issues that the developers are planning on working soon.
# -Sheila

# 4g
# Although GATK4 Mutect2 is optimized to accomodate varying coverage depths, further optimization of parameters is necessary for extreme high depths, e.g. 1000X.
# on shark we have about 380/24: 16G/core

# **** gatk4 mutect2 speed issue --------
#' https://github.com/bcbio/bcbio-nextgen/issues/1969x
#' That does sound reasonable to me -- we tend to run WGS somatic samples at 128 or 256 cores, and the whole pipeline takes 40 or 30 hours, respectively. 
#' MuTect2 and VarDict can stall on regions with extremely high coverage but that usually results in no CPU activity, i.e., the process just hangs.


# **** NEED to use -L intervals
#' https://gatkforums.broadinstitute.org/gatk/discussion/4133/when-should-i-use-l-to-pass-in-a-list-of-intervals
#' Below is a step-by-step breakdown of the Best Practices workflow, with a detailed explanation of why -L should or shouldn’t be used with each tool.
#' 
#' Tool	-L?	Why / why not
#' BaseRecalibrator	YES	This excludes off-target sequences and sequences that may be poorly mapped, which have a higher error rate. Including them could lead to a skewed model and bad recalibration.
#' PrintReads	NO	Output is a bam file; using -L would lead to lost data.
#' UnifiedGenotyper/Haplotype Caller	YES	We’re only interested in making calls in exome regions; the rest is a waste of time & includes lots of false positives.
#' Next steps	NO	No need since subsequent steps operate on the callset, which was restricted to the exome at the calling step.

# extract_seqname <- function(bam,
#                             outprefix,
#                             gatk4_exe = opts_flow$get('gatk4_exe')){
#   cmd_sampname = glue("{gatk4_exe} GetSampleName -I {bam} -O {outprefix}.txt") %>% as.character()
#   cmd_sampname
# }



#' @name mutect2.gatk4
#' 
#' 
#' @description A wrapper around somatic mutation caller MuTect
#'This generates a set of commandlines, per chromosome
#' following this: 
#' https://software.broadinstitute.org/gatk/documentation/article?id=11136
#' https://gatkforums.broadinstitute.org/gatk/discussion/11127
#' param details:
#' https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_walkers_mutect_Mutect2.php
#'
#' @param tumor_bam path to a tumor bam file
#' @param normal_bam path to a normal bam file
#' @param samplename name of the sample, to be added to the flowmat
#' @param tumor_name 
#' @param normal_name 
#' @param outprefix 
#' @param ref_fasta 
#' @param java_exe 
#' @param java_mem 
#' @param gatk4_exe 
#' @param mutect2_cpu 
#' @param mutect2_mem 
#' @param mutect2_opts 
#' @param mutect2_create_bam_out 
#' @param pon_m2_vcf 
#' @param germline_vcf 
#' @param germline_biallelic_vcf 
#' @param interval_split 
#' @param split_by_chr fork running mutect by chromosome to make it faster [TRUE]. Turning is option OFF is not fully supported.
#'
#' @return The function returns a flowmat with all the commands. 
#' The final file is called \code{'outprefix'_merged.mutect.tsv}.
#'
#' @import flowr
#' 
#' @export
#'
#' @examples \dontrun{
#'
#' x = "tumor.bam"
#' y = "normal.bam"
#'
#' out = mutect(x, y, samplename="tumor_normal", is_merged = TRUE)
#'
#' }
mutect2.gatk4.1.2.0 <- function(
  trk, 
  samplename,
  variant_calling_mode,
  
  # tumor_bam,
  # normal_bam,
  # tumor_name, normal_name,
  # 
  # # patient id
  # samplename,
  # 
  # # mutect outprefix (for final calls)
  # outprefix,
  
  #is_merged = TRUE,
  split_by_chr = TRUE,
  
  ref_fasta = opts_flow$get('ref_fasta'),
  
  java_exe = opts_flow$get("java_exe"),
  #java_opts = opts_flow$get("java_opts"),
  java_mem = opts_flow$get('java_mem_str'),
  
  gatk4_exe = opts_flow$get('gatk4_exe'),
  
  mutect2_cpu = opts_flow$get('mutect2_cpu'),
  mutect2_mem = opts_flow$get("mutect2_mem"),
  mutect2_opts = opts_flow$get('mutect2_opts'),
  mutect2_create_bam_out = opts_flow$get('mutect2_create_bam_out'),
  mutect2_pon_vcf = opts_flow$get("mutect2_pon_vcf"),
  mutect2_merge_stats_exe = opts_flow$get("mutect2_merge_stats_exe"),
  
  germline_vcf = opts_flow$get('germline_variants_vcf'),
  # for contamination
  germline_biallelic_vcf = opts_flow$get('germline_variants_biallelic_vcf'),
  
  # we can use these generic intervals for all kinds of files and 
  # filter later
  interval_split = opts_flow$get("capture_bi_wex_booster_intervals_split")
  
  
){
  
  # expect ALL non null args
  check_args(ignore = "mutect2_pon_vcf")
  
  # check generic columns
  trk = metadata_for_mutect1(trk)
  expect_columns(trk, "outprefix")
  if(variant_calling_mode == "matched")
    expect_columns(trk, "outprefix_paired")
  
  trk_tum = filter(trk, normal == "NO")
  trk_norm = filter(trk, normal == "YES")
  
  # for now this will ONLY work for single tumor sample
  # this maybe needs to be a loop!
  i=1
  tumor_bam = trk_tum$bam[i]
  normal_bam = trk_norm$bam[1] # assuming a SINGLE normal!!
  tumor_name = trk_tum$name[i]
  normal_name = trk_norm$name[1]
  outprefix = trk_tum$outprefix_paired[i]
  
  bamset = bam_set(bam = tumor_bam, 
                   outprefix = outprefix,
                   ref_fasta = ref_fasta, 
                   interval_split = interval_split,
                   split_by = "interval_split")
  
  # pipename = match.call()[[1]]
  flog.debug(paste0("Generating a mutect2 flowmat for sample: ", samplename))

  # mutect2 ---------
  #mutect_opts = "--artifact_detection_mode -rf ReassignOneMappingQuality -RMQF 255 -RMQT 60 -U ALLOW_N_CIGAR_READS -L $regions_bed_fl"
  mutect_vcfs = paste0(bamset$outprefix_interval, ".mutect.vcf")
  mutect_f1r2s = paste0(bamset$outprefix_interval, ".f1r2.tar.gz")
  # -bamout {mutect_bams} 
  gatk_intervals = bamset$intervals
  cmd_mutect <- glue("tname=$({gatk4_exe} GetSampleName -I {tumor_bam} -O /dev/stdout 2> /dev/null); ",
                     "nname=$({gatk4_exe} GetSampleName -I {normal_bam} -O /dev/stdout 2> /dev/null); ",
                     "{gatk4_exe} --java-options '-Xmx{mutect2_mem}g -XX:+UseParallelGC -XX:ParallelGCThreads={mutect2_cpu}' ",
                     "Mutect2 -R {ref_fasta} -I {tumor_bam} -I {normal_bam} ",
                     "-tumor $tname -normal $nname ",
                     "-pon {mutect2_pon_vcf} ",
                     
                     # ALL these have been added to mutect2_opts
                     # this is critical for next filter steps
                     # "--f1r2-tar-gz f1r2.tar.gz ",
                     # this is required for the new learnorientation model
                     # need brca1/2 variants, so emit germline ALSO, forcefully
                     # https://support.bioconductor.org/p/107739/,
                     # "--genotype-germline-sites ",
                     # "-A ReferenceBases ",
                     "--f1r2-tar-gz {mutect_f1r2s} ",
                     
                     "--germline-resource {germline_vcf} ",
                     "--native-pair-hmm-threads {mutect2_cpu} ",
                     "-O {mutect_vcfs} {mutect2_opts} {gatk_intervals}")
  
  # cmd_mutect[17]
  # gatk --java-options "-Xmx2g" Mutect2 
  # -R hg38/Homo_sapiens_assembly38.fasta \
  # -I tumor.bam -I normal.bam  -tumor HCC1143_tumor  -normal HCC1143_normal \
  # -pon resources/chr17_pon.vcf.gz \
  # --germline-resource resources/chr17_af-only-gnomad_grch38.vcf.gz \
  # --af-of-alleles-not-in-resource 0.0000025 --disable-read-filter MateOnSameContigOrNoMappedMateReadFilter \
  # -L chr17plus.interval_list -O 1_somatic_m2.vcf.gz -bamout 2_tumor_normal_m2.bam 
  
  # ** merge VCFs ---------
  mutect_vcf = paste0(outprefix, ".vcf.gz")
  mutect_vcfs_i = paste0(mutect_vcfs, collapse = " -I ")
  # GatherVcfs
  # https://software.broadinstitute.org/gatk/documentation/tooldocs/current/picard_vcf_GatherVcfs.php
  # gather should be faster
  mutect2dir = basename(outprefix)
  cmd_mergevcf = glue("{gatk4_exe} --java-options {java_mem} GatherVcfs -I {mutect_vcfs_i} -O {mutect_vcf}; ", 
                      "bash {mutect2_merge_stats_exe} '{mutect2dir}/*vcf.gz.stats' {mutect_vcf}.stats;",
                      "{gatk4_exe} IndexFeatureFile -I {mutect_vcf}")

  # we need two arguments, pattern and output file filename for the stats
  
  # this will be critical in ALL validation (in IGV)
  if(mutect2_create_bam_out){
    mutect_bams = paste0(bamset$outprefix_interval, ".mutect.bam")
    cmd_mutect = glue("{cmd_mutect} -bamout {mutect_bams}")
    # ** gather bams ----
    mutect_bams_i = paste0(mutect_bams, collapse = " -I ");
    mutect_bam_o = paste0(outprefix, "_mutect.bam")
    cmd_mutect_gather_bams <- glue("{gatk4_exe} --java-options {java_mem} GatherBamFiles ",
                                   "-I {mutect_bams_i} -O {mutect_bam_o} --CREATE_INDEX true --CREATE_MD5_FILE true")
    cmd_mergevcf = c(cmd_mergevcf, cmd_mutect_gather_bams)
  }
  
  
  # ** contamination/pipelup;f1 ---------
  # best to use a set of biallelic calls
  # (maybe only chr1 is enough)
  # https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_walkers_contamination_CalculateContamination.php
  
  
  # This tool borrows from ContEst by Cibulskis et al the idea of estimating contamination from ref reads at hom alt sites. 
  # However, ContEst uses a probabilistic model that assumes a diploid genotype with no copy number variation and independent 
  # contaminating reads. That is, ContEst assumes that each contaminating read is drawn randomly and independently from a different human. 
  # This tool uses a simpler estimate of contamination that relaxes these assumptions. 
  # In particular, it works in the presence of copy number variations and with an arbitrary number of contaminating samples. 
  # In addition, this tool is designed to work well with no matched normal data. 
  # However, one can run GetPileupSummaries on a matched normal bam file and input the result to this tool.
  tumor_pileup = glue("{tumor_name}_pileup.table")
  normal_pileup = glue("{normal_name}_pileup.table")
  tumor_cont_tab = glue("{tumor_name}_contamination.table")
  #normal_cont_tab = glue("{normal_bam_prefix}_contamination.table")
  
  # the variants are in chr 1 only
  # 1 is larger, hopefully it would work well
  cmd_pileup1 = glue("{gatk4_exe} GetPileupSummaries -I {tumor_bam} -V {germline_biallelic_vcf} -O {tumor_pileup} -L 1")
  cmd_pileup2 = glue("{gatk4_exe} GetPileupSummaries -I {normal_bam} -V {germline_biallelic_vcf} -O {normal_pileup} -L 1")
  cmd_pileup = c(cmd_pileup1, cmd_pileup2)
  #' This produces a six-column table as shown. The alt_count is the count of reads that support the ALT allele in the germline resource. 
  #' The allele_frequency corresponds to that given in the germline resource. Counts for other_alt_count refer to reads that support all other alleles.
  cmd_cont = glue("{gatk4_exe} CalculateContamination -I {tumor_pileup} -matched {normal_pileup} ",
                  "-O {tumor_cont_tab}")
  cmd_cont
  
  mutect_filt1_vcf = paste0(outprefix, "_f1.vcf.gz")
  mutect_filt2_vcf = paste0(outprefix, "_f2.vcf.gz")
  cmd_filter1 = glue("{gatk4_exe} FilterMutectCalls -V {mutect_vcf} -R {ref_fasta} --contamination-table {tumor_cont_tab} -O {mutect_filt1_vcf}")
  
  # https://gatkforums.broadinstitute.org/gatk/discussion/comment/57611
  # ** LearnReadOrientationModel ---------
  mutect_f1r2_i = paste0(mutect_f1r2s, collapse = " -I ")
  mutect_f1r2 = paste0(outprefix, ".read-orientation-model.tar.gz")
  cmd_learnf1r2 = glue("{gatk4_exe} LearnReadOrientationModel -I {mutect_f1r2_i} -O {mutect_f1r2}")
  # need to start with original file, this step needs the calls.vcf.stats file
  cmd_filter2 = glue("{gatk4_exe} FilterMutectCalls -V {mutect_vcf} -R {ref_fasta} ",
                     "--contamination-table {tumor_cont_tab} --ob-priors {mutect_f1r2} -O {mutect_filt2_vcf}")

  cmds <- list(mutect2.splt = cmd_mutect, 
               mutect2.mrg = cmd_mergevcf,
               mutect2.mrg = cmd_pileup,
               mutect2.mrg = cmd_cont,
               mutect2.mrg = cmd_filter1,
               mutect2.mrg = cmd_learnf1r2,
               mutect2.mrg = cmd_filter2)
  # mutect_gather_bams = cmd_mutect_gather_bams
  
  flowmat = to_flowmat(cmds, samplename = samplename) %>% 
    mutate(cmd = as.character(cmd))
  
  ret = list(flowmat=flowmat, 
             outfiles = mutect_filt2_vcf, 
             outfiles2 = c(mutect_filt2_vcf = mutect_filt2_vcf, 
                           mutect_filt1_vcf = mutect_filt1_vcf,
                           tumor_cont_tab = tumor_cont_tab,
                           #mutect_bam = mutect_bam_o,
                           mutect_vcf = mutect_vcf))
  ret
  
}

# --f1r2-tar-gz f1r2.tar.gz







# END
