

# gatk 4.1.1.0 --------
# Mutect2
# 
# Overhaul of FilterMutectCalls, which now applies a single threshold to an overall error probability (#5688)
# FilterMutectCalls automatically determines the optimal threshold.
# The new somatic clustering model learns tumors' allele fraction spectra and overall SNV and indel mutation rates in order to improve filtering.
# Includes a rewrite of Mutect2 documentation -- better organization and now includes command line examples in addition to math.
# Mutect2 now modifies base and indel qualities of overlapping paired reads to account for PCR error rather than discarding reads (#5794)
# This especially improves indel sensitivity.
# Optimized Mutect2 read orientation filtering by collecting F1R2 counts from within Mutect2 itself, greatly reducing wall-clock and CPU time (#5840)
# New Mutect2 panel of normals workflow using GenomicsDB for scalability (#5675)
# Panel of normals removes germline variants in order to contain only technical artifacts, and contains information about artifact prevalence
# Rewrote Mutect2 active region likelihood as special case of full somatic likelihoods model, which reduces runtime by 5% (#5814)
# Funcotator updates in Mutect2 WDL (#5742) (#5735)
# Prune assemby graph before checking for cycles (#5562)
# Refactor Mutect2 inheritance so that it doesn't have inactive arguments (#5758)
# Added CRAM support to the Mutect2 WDL (#5668)
# Split MNPs in Mutect2 PON WDL, fixing a potential bug (#5706)
# Handle negative infinity log likelihoods from PairHMM in Mutect2 (#5736)
# Fixed overfiltering in Mutect2 in GGA alleles mode with no reads (#5743)
# Correct some Mutect2 VCF header lines (#5792)
# Handle unmarked duplicates with mate MQ = 0 in Mutect2 (#5734)
# Output sample names in Mutect2 PON header (#5733)
# Avoid error due to finite precision error in Mutect2 PON creation (#5797)
# Update Mutect2 javadoc to reflect v4.1 changes. (#5769)
# Renamed the OxoGReadCounts annotation to OrientationBiasReadCounts (#5840)



## ** Primary resources ** (optional but strongly recommended)
## pon, pon_index: optional panel of normals in VCF format containing probable technical artifacts (false positves)
## gnomad, gnomad_index: optional database of known germline variants (see http://gnomad.broadinstitute.org/downloads)
## variants_for_contamination, variants_for_contamination_index: VCF of common variants with allele frequencies for calculating contamination
##
## ** Secondary resources ** (for optional tasks)
## onco_ds_tar_gz, default_config_file: Oncotator datasources and config file
## sequencing_center, sequence_source: metadata for Oncotator
## filter_oncotator_maf: Whether the MAF generated by oncotator should have the filtered variants removed. Default: true
## realignment_index_bundle: resource for FilterAlignmentArtifacts, which runs if and only if it is specified.  Generated by BwaMemIndexImageCreator.

# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf . # Mutect2.gnomad 
# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf.idx . # Mutect2.gnomad_index
# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf . # Mutect2.variants_for_contamination 
# gsutil -m cp -r gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf.idx . # Mutect2.variants_for_contamination_index 
# gsutil ls gs://gatk-best-practices/somatic-b37
# gs://gatk-best-practices/somatic-b37/
# gs://gatk-best-practices/somatic-b37/CNV.hg19.bypos.v1.CR1_event_added.mod.seg
# gs://gatk-best-practices/somatic-b37/HCC1143.bai
# gs://gatk-best-practices/somatic-b37/HCC1143.bam
# gs://gatk-best-practices/somatic-b37/HCC1143_normal.bai
# gs://gatk-best-practices/somatic-b37/HCC1143_normal.bam
# gs://gatk-best-practices/somatic-b37/Homo_sapiens_assembly19.dict
# gs://gatk-best-practices/somatic-b37/Homo_sapiens_assembly19.fasta
# gs://gatk-best-practices/somatic-b37/Homo_sapiens_assembly19.fasta.fai
# gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf
# gs://gatk-best-practices/somatic-b37/af-only-gnomad.raw.sites.vcf.idx
# gs://gatk-best-practices/somatic-b37/final_centromere_hg19.seg
# gs://gatk-best-practices/somatic-b37/onco_config.txt
# gs://gatk-best-practices/somatic-b37/oncotator_v1_ds_April052016.tar.gz
# gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf
# gs://gatk-best-practices/somatic-b37/small_exac_common_3.vcf.idx
# gs://gatk-best-practices/somatic-b37/whole_exome_agilent_1.1_refseq_plus_3_boosters.Homo_sapiens_assembly19.baits.interval_list
# gs://gatk-best-practices/somatic-b37/whole_exome_agilent_1.1_refseq_plus_3_boosters.Homo_sapiens_assembly19.targets.interval_list


# *** split intervals for mutect:
# interval=whole_exome_agilent_1.1_refseq_plus_3_boosters.Homo_sapiens_assembly19.targets.interval_list
# gatk SplitIntervals -R Homo_sapiens_assembly19.fasta -L ${interval} --scatter-count 20 -O .

# **** CREATE contamination VCF -------
# https://gatkforums.broadinstitute.org/gatk/discussion/1255/using-jexl-to-apply-hard-filters-or-select-varia
# https://gatkforums.broadinstitute.org/gatk/discussion/comment/21120#Comment_21120; issue with multi allelic sites
# gatk SelectVariants -V af-only-gnomad.raw.sites.vcf -L 1 -R Homo_sapiens_assembly19.fasta --select 'AF.0 > 0.05' -O af-only-gnomad.raw.sites_for_contamination_chr1.vcf
# gatk IndexFeatureFile af-only-gnomad.raw.sites_for_contamination_chr1.vcf


# **** ARTEFECT filtering -----
# Mutect2.artifact_modes -- List of artifact modes to search for in the orientation bias filter. For example to filter the OxoG artifact, you would specify ["G/T"]. For both the FFPE artifact and the OxoG artifact, specify ["G/T", "C/T"]. If you do not wish to search for any artifacts, please set Mutect2_Multi.is_run_orientation_bias_filter to false.

# ** optimizing speed -------
# I heard back from a developer, and he has some questions/tips which I will relay here.
# 1) Do you have the log (stdout + stderr) for the GATK4 non-spark run? Can you post it? The developers need to know which pairhmm you are running with.
# 2) What sort of hardware are you running on? Specifically, is it an Intel machine with support for AVX?
# 3) A good setting for--nativePairHmmThreads is probably 4-8; you won't see any improvement after that.
# 4) You are setting -XX:+UseParallelGC -XX:ParallelGCThreads=32 for the GATK3 run. You would be better off setting it to 2-4 threads. Performance gets worse beyond that typically from what the developers have seen. You can set the same thing in GATK4 using--javaOptions ' -XX:+UseParallelGC -XX:ParallelGCThreads=4' This will also give us a better comparison.
# 5) In general, you want executors with ~4-8 cores and at least 4g of memory per core. How much memory do your nodes have and are you running with autoscaling turned on? I suspect you are only allocating 1 executor on 1 node and then it's thrashing memory because it's trying to run 32 threads at once. Spark tuning for HaplotypeCaller is going to be complicated. The developers don't know how to do it well yet, but they will be working on it in the next few months. It looks like you are running with Spark 2.1.0. GATK4 currently requires Spark 2.0.2 (which is unfortunately a specific version), but the developers are planning on upgrading to spark 2.2.+ in the next few months.
# To be clear, the results will not be the same between GATK3, GATK4, and GATK4-spark yet. GATK4 is in a rapid state of flux and has known performance issues that the developers are planning on working soon.
# -Sheila

# 4g
# Although GATK4 Mutect2 is optimized to accomodate varying coverage depths, further optimization of parameters is necessary for extreme high depths, e.g. 1000X.
# on shark we have about 380/24: 16G/core

# **** gatk4 mutect2 speed issue --------
#' https://github.com/bcbio/bcbio-nextgen/issues/1969x
#' That does sound reasonable to me -- we tend to run WGS somatic samples at 128 or 256 cores, and the whole pipeline takes 40 or 30 hours, respectively. 
#' MuTect2 and VarDict can stall on regions with extremely high coverage but that usually results in no CPU activity, i.e., the process just hangs.


# **** NEED to use -L intervals
#' https://gatkforums.broadinstitute.org/gatk/discussion/4133/when-should-i-use-l-to-pass-in-a-list-of-intervals
#' Below is a step-by-step breakdown of the Best Practices workflow, with a detailed explanation of why -L should or shouldn’t be used with each tool.
#' 
#' Tool	-L?	Why / why not
#' BaseRecalibrator	YES	This excludes off-target sequences and sequences that may be poorly mapped, which have a higher error rate. Including them could lead to a skewed model and bad recalibration.
#' PrintReads	NO	Output is a bam file; using -L would lead to lost data.
#' UnifiedGenotyper/Haplotype Caller	YES	We’re only interested in making calls in exome regions; the rest is a waste of time & includes lots of false positives.
#' Next steps	NO	No need since subsequent steps operate on the callset, which was restricted to the exome at the calling step.


#' @name mutect2.gatk4
#' 
#' 
#' @description A wrapper around somatic mutation caller MuTect
#'This generates a set of commandlines, per chromosome
#' following this: 
#' https://software.broadinstitute.org/gatk/documentation/article?id=11136
#' https://gatkforums.broadinstitute.org/gatk/discussion/11127
#' param details:
#' https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_walkers_mutect_Mutect2.php
#'
#' @param tumor_bam path to a tumor bam file
#' @param normal_bam path to a normal bam file
#' @param samplename name of the sample, to be added to the flowmat
#' @param out_prefix output file name [optional]. By default, this is created using names of tumor and normal bam files.
#' @param is_merged specify if the input bam is already split by chromosomes (FALSE) or is a merged file with all chromosome (TRUE). [FALSE]
#' @param split_by_chr fork running mutect by chromosome to make it faster [TRUE]. Turning is option OFF is not fully supported.
#' @param java_exe path to java's executable [java]
#' @param java_tmp path to a temp folder to be used by java
#' @param mutect_jar path to mutect's jar file
#' @param cpu_mutect integer specifying number of thread to be used per mutect fork
#' @param mem_mutect amount of memory to be used by mutect [-Xmx12g]
#' @param ref_fasta path to the reference genome in fasta format
#' @param mutect_opts additional arguments passed onto mutect
#' 
#' @return The function returns a flowmat with all the commands. 
#' The final file is called \code{'out_prefix'_merged.mutect.tsv}.
#'
#' @import flowr
#' 
#' @export
#'
#' @examples \dontrun{
#'
#' x = "tumor.bam"
#' y = "normal.bam"
#'
#' out = mutect(x, y, samplename="tumor_normal", is_merged = TRUE)
#'
#' }
mutect2.gatk4 <- function(
  tumor_bam,
  normal_bam,
  tumor_name, normal_name,
  samplename = opts_flow$get("samplename"),

  #is_merged = TRUE,
  split_by_chr = TRUE,
  
  ref_fasta = opts_flow$get('ref_fasta'),
  
  java_exe = opts_flow$get("java_exe"),
  #java_opts = opts_flow$get("java_opts"),
  java_mem = opts_flow$get('java_mem'),
  
  gatk4_exe = opts_flow$get('gatk4_exe'),
  
  mutect.cpu = opts_flow$get('mutect.cpu'),
  mutect.mem = opts_flow$get("mutect.mem"),
  mutect_opts = opts_flow$get('mutect_opts'),
  
  germline_vcf = opts_flow$get('germline_vcf'),
  germline_small_vcf = opts_flow$get('germline_small_vcf'),
  
  gatk_intervals_fl = opts_flow$get("gatk_C1_intervals")
  
  ){
  
  check_args(ignore = "out_prefix")
  
  # tumor_name = "T10";normal_name="N10"
  # tumor_bam = "JCOxSARCO-T10_1208XX_ST1374_073_H09WGADXX.duplicates_marked.recalibrated.bam";
  # normal_bam = "JCOxSARCO-N10_1208XX_ST1374_073_H09WGADXX.duplicates_marked.bam"
  
  bamset  = bam_set(bam = tumor_bam, ref_fasta_path = ref_fasta, split_by_chr = T)
  tumor_bam_prefix = tools::file_path_sans_ext(tumor_bam)
  normal_bam_prefix = tools::file_path_sans_ext(normal_bam)
  
  
  #opts_flow$load("somatic_snv_indels.conf")
  
  #mutect_opts = "--artifact_detection_mode -rf ReassignOneMappingQuality -RMQF 255 -RMQT 60 -U ALLOW_N_CIGAR_READS -L $regions_bed_fl"
  mutect_vcfs = paste0(bamset$out_prefix_interval, ".mutect.vcf")
  mutect_bams = paste0(bamset$out_prefix_interval, ".mutect.bam")
  gatk_intervals = bamset$gatk_intervals
  cmd_mutect <- glue("{gatk4_exe} --java-options '{mutect.mem} -XX:+UseParallelGC -XX:ParallelGCThreads={mutect.cpu}' ",
                     "Mutect2 -R {ref_fasta} -I {tumor_bam} -I {normal_bam} ",
                     "-tumor {tumor_name} -normal {normal_name} ",
                     "--germline-resource {germline_vcf} ",
                     "-bamout {mutect_bams} --native-pair-hmm-threads {mutect.cpu} ",
                     "-O {mutect_vcfs} {mutect_opts} {gatk_intervals}")
  cmd_mutect[17]
  # gatk --java-options "-Xmx2g" Mutect2 
  # -R hg38/Homo_sapiens_assembly38.fasta \
  # -I tumor.bam -I normal.bam  -tumor HCC1143_tumor  -normal HCC1143_normal \
  # -pon resources/chr17_pon.vcf.gz \
  # --germline-resource resources/chr17_af-only-gnomad_grch38.vcf.gz \
  # --af-of-alleles-not-in-resource 0.0000025 --disable-read-filter MateOnSameContigOrNoMappedMateReadFilter \
  # -L chr17plus.interval_list -O 1_somatic_m2.vcf.gz -bamout 2_tumor_normal_m2.bam 

  # ** merge VCFs ---------
  mutect_vcf = paste0(samplename, ".vcf")
  mutect_vcfs_i = paste0(mutect_vcfs, collapse = " -I ")
  cmd_mergevcf = glue("{gatk4_exe} --java-options {java_mem} MergeVcfs -I {mutect_vcfs_i} -O {mutect_vcf} ")
  # ** gather bams ----
  mutect_bams_i = paste0(mutect_bams, collapse = " -I ");
  mutect_bam_o = paste0(bamset$out_prefix, "_mutect.bam")
  cmd_mutect_gather_bams <- glue("{gatk4_exe} --java-options {java_mem} GatherBamFiles ", 
                          "-I {mutect_bams_i} -O {mutect_bam_o} --CREATE_INDEX true --CREATE_MD5_FILE true")
  cmd_mergevcf = c(cmd_mergevcf, cmd_mutect_gather_bams)
  
  # ** contamination/pipelup;f1 ---------
  tumor_pileup = glue("{tumor_bam_prefix}_pileup.table")
  normal_pileup = glue("{normal_bam_prefix}_pileup.table")
  tumor_cont_tab = glue("{tumor_bam_prefix}_contamination.table")
  #normal_cont_tab = glue("{normal_bam_prefix}_contamination.table")
  
  cmd_pileup1 = glue("{gatk4_exe} GetPileupSummaries -I {tumor_bam} -V {germline_small_vcf} -O {tumor_pileup} -L {gatk_intervals_fl}")
  cmd_pileup2 = glue("{gatk4_exe} GetPileupSummaries -I {normal_bam} -V {germline_small_vcf} -O {normal_pileup} -L {gatk_intervals_fl}")
  cmd_pileup = c(cmd_pileup1, cmd_pileup2)
  #' This produces a six-column table as shown. The alt_count is the count of reads that support the ALT allele in the germline resource. 
  #' The allele_frequency corresponds to that given in the germline resource. Counts for other_alt_count refer to reads that support all other alleles.
  cmd_cont = glue("{gatk4_exe} CalculateContamination -I {tumor_pileup} -matched {normal_pileup} ",
                    "-O {tumor_cont_tab}")
  cmd_cont
  
  mutect_filt1_vcf = paste0(samplename, "_filt1.vcf")
  cmd_filter1 = glue("{gatk4_exe} FilterMutectCalls -V {mutect_vcf} --contamination-table {tumor_cont_tab} -O {mutect_filt1_vcf}")
  
  # ** contamination/pipelup;f2 ---------
  #tumor_artifact = paste0(tumor_bam_prefix, "_seq_artifact")
  cmd_collect_seq_artifact = glue("{gatk4_exe} CollectSequencingArtifactMetrics -I {tumor_bam} ",
                                   "-O {tumor_bam_prefix} ", # –EXT '.txt' have some issue here
                                   "-R {ref_fasta}")
  cmd_collect_seq_artifact
  
  #' Second, perform orientation bias filtering with FilterByOrientationBias. 
  #' We provide the tool with the once-filtered calls 9_somatic_oncefiltered.vcf.gz, 
  #' the pre_adapter_detail_metrics file and the sequencing contexts for FFPE (C→T transition) and OxoG (G→T transversion). 
  #' The tool knows to include the reverse complement contexts
  #' https://software.broadinstitute.org/gatk/documentation/tooldocs/current/org_broadinstitute_hellbender_tools_exome_FilterByOrientationBias.php
  mutect_filt2_vcf = paste0(samplename, "_filt2.vcf")
  cmd_filter2 = glue("{gatk4_exe} FilterByOrientationBias --artifact-modes 'G/T' --artifact-modes 'C/T' -V {mutect_filt1_vcf} ",
                     "-P {tumor_bam_prefix}.pre_adapter_detail_metrics -O {mutect_filt2_vcf}")
  
  cmds <- list(mutect = cmd_mutect, 
               mutect_mergevcf = cmd_mergevcf,
               mutect_pileup = cmd_pileup,
               mutect_contamination = cmd_cont,
               mutect_filt1 = cmd_filter1,
               mutect_collect_seq_art = cmd_collect_seq_artifact,
               mutect_filt2 = cmd_filter2)
               #mutect_gather_bams = cmd_mutect_gather_bams
  
  flowmat = to_flowmat(cmds, samplename = samplename) %>% 
    mutate(cmd = as.character(cmd))
  
  ret = list(flowmat=flowmat, 
              outfiles = mutect_filt2_vcf, 
              outfiles2 = c(mutect_filt2_vcf = mutect_filt2_vcf, 
                            mutect_filt1_vcf = mutect_filt1_vcf,
                            tumor_cont_tab = tumor_cont_tab,
                            mutect_bam = mutect_bam_o,
                            mutect_vcf = mutect_vcf))
  ret
  
}


